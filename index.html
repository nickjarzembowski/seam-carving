<html>
<body>
  <style>
    * {
      margin:0;
      padding:0
    }
    canvas,#container p {
      display:inline-block;
      width:20vw;
    }
    #container {
      text-align:center;
    }
  </style>
  <div id="container">
    <p>Original</p>
    <p>Horizontal gradients</p>
    <p>Vertical gradients</p>
    <p>Seams</p>
  </div>
  <div id="container">
    <canvas id="canvas"></canvas>
    <canvas id="canvas_extra"></canvas>
    <canvas id="canvas_h_grad"></canvas>
    <canvas id="canvas_seam"></canvas>
  </div>
</body>
<script>

  // canvas containing the original image with seams removed
  var canvas = document.getElementById('canvas');
  var ctx = canvas.getContext('2d');

  // canvas containing the horizontal gradients of the img in canvas
  var canvas_extra = document.getElementById('canvas_extra');
  var ctx_extra = canvas_extra.getContext('2d');

  // canvas containing the vertical gradients of the img in canvas
  var canvas_h_grad = document.getElementById('canvas_h_grad');
  var ctx_h_grad = canvas_h_grad.getContext('2d');
  canvas.style.backgroundColor = 'rgba(158, 167, 184, 255)';

  // canvas containing the seams found after each iteration
  var canvas_seam = document.getElementById('canvas_seam');
  var ctx_seam = canvas_seam.getContext('2d');




  window.onload = function(){
    IMG_LOADED = false;

    // load image
    var img = new Image();
    img.src = './p2.png';
    img.crossOrigin = "Anonymous";
    img.onload = function() {
      ctx.canvas.width = img.width;
      ctx.canvas.height = img.height;
      ctx_extra.canvas.width = img.width;
      ctx_extra.canvas.height = img.height;
      ctx_seam.canvas.width = img.width;
      ctx_seam.canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      image_data = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
      height = image_data.height;
      width = image_data.width;
      ctx_seam.putImageData(image_data,0,0);
      // horizontal
      ctx_h_grad.canvas.width = img.width
      ctx_h_grad.canvas.height = img.height;

      IMG_LOADED = true;
    }

    // Key handler
    var keyState = {};
    window.addEventListener('keydown',function(e){
        keyState[e.keyCode || e.which] = true;
    },true);
    window.addEventListener('keyup',function(e){
        keyState[e.keyCode || e.which] = false;
    },true);

    function key_handler_loop() {
      if (keyState[72]) remove_vertical_seam()
      setTimeout(key_handler_loop, 10);
    }
    key_handler_loop();
  }

  function remove_vertical_seam() {
    if (!IMG_LOADED) return;

    timer.begin()

    image_data = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
    height = image_data.height;
    width = image_data.width;

    ctx.canvas.width = width;
    ctx.canvas.height = height;
    ctx_extra.canvas.width = width;
    ctx_extra.canvas.height = height;
    ctx_seam.canvas.width = width;
    ctx_seam.canvas.height = height;

    ctx_h_grad.canvas.width = width;
    ctx_h_grad.canvas.height = height;

    ctx.putImageData(image_data,0,0);
    ctx_seam.putImageData(image_data,0,0);

    // compute horizontal gradients
    var grad = new Array(width)
    for (i = 0; i < width; i++){
      grad[i] = new Array(height)
    }

    imgData = ctx_extra.getImageData(0,0,ctx_extra.canvas.width,ctx_extra.canvas.height)

    // compute vertical gradients
    nWidth = width*4;
    nHeight = height*4;
    for (y = 0; y < nHeight; y+=4) {
      for (x = 0; x < nWidth; x+=4) {

        idx = x + y * width

        center_r = image_data.data[idx]
        center_g = image_data.data[idx+1]
        center_b = image_data.data[idx+2]
        center_a = image_data.data[idx+3]

        left = (x == 0 ? idx : ( (x-4) + y * width))
        right = (x == nWidth-1 ? idx : ( (x+4) + y * width))

        left_r = image_data.data[left]
        left_g = image_data.data[left+1]
        left_b = image_data.data[left+2]
        left_a = image_data.data[left+3]

        right_r = image_data.data[right]
        right_g = image_data.data[right+1]
        right_b = image_data.data[right+2]
        right_a = image_data.data[right+3]

        r = left_r - right_r;
        g = left_g - right_g;
        b = left_b - right_b;

        distance = Math.sqrt(r*r + g*g + b*b);

        grad[x/4][y/4] = distance

        // check i'm scanning ok
        imgData.data[idx] = center_r
        imgData.data[idx+1] = center_g
        imgData.data[idx+2] = center_b
        imgData.data[idx+3] = center_a
      }
    }
    ctx_extra.putImageData(imgData,0,0);

    // draw vertical gradients
    imgData = ctx_extra.getImageData(0,0,ctx_extra.canvas.width,ctx_extra.canvas.height);
    for (y = 0; y < height; y++) {
      for (x = 0; x < width; x++) {
        n = grad[x][y];
        r = n >> 24 & 255;
        g = n >> 16 & 255;
        b = n >> 8 & 255;
        a = n >> 0 & 255;
        i = (x*4 + y*4 * width)
        imgData.data[i]=r;
        imgData.data[i+1]=g;
        imgData.data[i+2]=b;
        imgData.data[i+3]=a;
      }
    }
    ctx_extra.putImageData(imgData,0,0);

    // compute horizontal gradients
    var grad_horizontal = new Array(width)
    for (i = 0; i < width; i++){
      grad_horizontal[i] = new Array(height)
    }
    for (x = 0; x < nWidth; x+=4) {
      for (y = 0; y < nHeight; y+=4) {

        idx = x + y * width

        center_r = image_data.data[idx]
        center_g = image_data.data[idx+1]
        center_b = image_data.data[idx+2]
        center_a = image_data.data[idx+3]

        up = (y == 0 ? idx : ( x + (y-4) * width))
        down = (y == nHeight-1 ? idx : ( x + (y+4) * width))

        up_r = image_data.data[up]
        up_g = image_data.data[up+1]
        up_b = image_data.data[up+2]
        up_a = image_data.data[up+3]

        down_r = image_data.data[down]
        down_g = image_data.data[down+1]
        down_b = image_data.data[down+2]
        down_a = image_data.data[down+3]

        r = up_r - down_r;
        g = up_g - down_g;
        b = up_b - down_b;

        distance = Math.sqrt(r*r + g*g + b*b);

        grad_horizontal[x/4][y/4] = distance
      }
    }

    // draw horizontal gradients
    imgData = ctx_h_grad.createImageData(ctx_h_grad.canvas.width,ctx_h_grad.canvas.height);
    for (x = 0; x < width; x++) {
      for (y = 0; y < height; y++) {
        n = grad_horizontal[x][y];
        r = n >> 24 & 255;
        g = n >> 16 & 255;
        b = n >> 8 & 255;
        a = n >> 0 & 255;
        i = (x*4 + y*4 * width)
        imgData.data[i]=r;
        imgData.data[i+1]=g;
        imgData.data[i+2]=b;
        imgData.data[i+3]=a;
      }
    }
    ctx_h_grad.putImageData(imgData,0,0);

    // sum vertical gradients
    vertical_fitness = new Array(width)
    for (var i = 0; i < width; i++) {
      vertical_fitness[i] = new Array(height)
    }
    for (var x = 0; x < width; x++) {
      vertical_fitness[x][0] = grad[x][0]
    }
    for (y = 1; y < height; y++) {
      for (x = 0; x < width; x++) {
        vertical_fitness[x][y] = grad[x][y]
        if (x == 0) {
          vertical_fitness[x][y] += Math.min(vertical_fitness[x][y-1], vertical_fitness[x+1][y-1]);
        } else if (x == width-1) {
          vertical_fitness[x][y] += Math.min(vertical_fitness[x][y-1], vertical_fitness[x-1][y-1]);
        } else {
          vertical_fitness[x][y] += Math.min(vertical_fitness[x-1][y-1], vertical_fitness[x][y-1], vertical_fitness[x+1][y-1]);
        }
      }
    }

    // find vertical seam with minimum total gradient
    var best = 0
    for (var x = 0; x < width; x++) {
      best = (vertical_fitness[x][height-1] < vertical_fitness[best][height-1]) ? x : best
    }
    seam = Array.apply(null, new Array(height)).map(Number.prototype.valueOf,0)
    seam = new Array()
    seam[0] = [best,y]
    for (y = height-1; y >= 0; y--) {
     left = (best == 0) ? best : (best-1);
     right = (best == width-1) ? best : (best+1);
     forward = (y == 0) ? y : (y-1);
     l = vertical_fitness[left][forward]
     r = vertical_fitness[right][forward]
     f = vertical_fitness[best][forward]
     best = (l < r) ? ( (l < f) ? left : best ) : right
     seam.push([best,y])
    }

    // draw minimum vertical seam
    imgData = ctx_seam.getImageData(0,0,ctx_seam.canvas.width,ctx_seam.canvas.height);
    for (var i=0; i<seam.length; i++) {
     x = seam[i][0]
     y = seam[i][1]
     z = (x*4 + y*4 * ctx.canvas.width)
     imgData.data[z+0]=255;
     imgData.data[z+1]=0;
     imgData.data[z+2]=0;
     imgData.data[z+3]=255;
    }
    ctx_seam.putImageData(imgData,0,0);

    // remove vertical seam from orignal img
    image_data = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
    new_image = ctx.createImageData(ctx.canvas.width,ctx.canvas.height);
    for (y = 0; y<height; y++) {
      x_offset = 0;
      for (x = 0; x<width-1; x++) {
        if (seam[y][0] == x) x_offset = 1
        new_image_idx = (x*4 + (height-1-y)*4 * ctx.canvas.width) // rotate the seam
        old_image_idx = ((x+x_offset)*4 + (height-1-y)*4 * ctx.canvas.width)
        new_image.data[new_image_idx+0]=image_data.data[old_image_idx];
        new_image.data[new_image_idx+1]=image_data.data[old_image_idx+1];
        new_image.data[new_image_idx+2]=image_data.data[old_image_idx+2];
        new_image.data[new_image_idx+3]=image_data.data[old_image_idx+3];
      }
    }
    ctx.canvas.width = ctx.canvas.width-1;
    ctx.putImageData(new_image,0,0);


    /** Horizontal Gradient **/
    // height = imgData.height;
    // width = imgData.width;

    // // sum horizontal gradients
    // horizontal_fitness = new Array(height)
    // for (var i = 0; i < height; i++) {
    //   horizontal_fitness[i] = new Array(width)
    // }
    // for (var y = 0; y < height; y++) {
    //   horizontal_fitness[0][y] = grad_horizontal[0][y]
    // }
    // for (x = 1; x < width; x++) {
    //   for (y = 0; y < height; y++) {
    //     horizontal_fitness[x][y] = grad_horizontal[x][y]
    //     if (y == 0) {
    //       horizontal_fitness[x][y] += Math.min(horizontal_fitness[x-1][y], horizontal_fitness[x-1][y+1]);
    //     } else if (y == height-1) {
    //       horizontal_fitness[x][y] += Math.min(horizontal_fitness[x-1][y], horizontal_fitness[x-1][y-1]);
    //     } else {
    //       horizontal_fitness[x][y] += Math.min(horizontal_fitness[x-1][y], horizontal_fitness[x-1][y+1], horizontal_fitness[x-1][y-1]);
    //     }
    //   }
    // }
    //
    // // find horizontal seam with minimum total gradient
    // var best = 0
    // for (var y = 0; y < height; y++) {
    //   best = (horizontal_fitness[width-1][y] < horizontal_fitness[width-1][best]) ? y : best
    // }
    // horizontal_seam = Array.apply(null, new Array(width)).map(Number.prototype.valueOf,0)
    // horizontal_seam = new Array()
    // horizontal_seam[0] = [width-1,best]
    // for (x = width-1; x >= 0; x--) {
    //  left = (best == 0) ? best : (best-1);
    //  right = (best == height-1) ? best : (best+1);
    //  forward = (x == 0) ? x : (x-1);
    //  l = horizontal_fitness[forward][left]
    //  r = horizontal_fitness[forward][right]
    //  f = horizontal_fitness[forward][best]
    //  best = (l < r) ? ( (l < f) ? left : best ) : right
    //  horizontal_seam.push([x,best])
    // }
    //
    // // draw minimum horizontal seam
    // imgData = ctx_seam.getImageData(0,0,ctx_seam.canvas.width,ctx_seam.canvas.height);
    // for (var i=0; i<horizontal_seam.length; i++) {
    //  x = horizontal_seam[i][0]
    //  y = horizontal_seam[i][1]
    //  z = (x*4 + y*4 * ctx.canvas.width)
    //  imgData.data[z+0]=255;
    //  imgData.data[z+1]=0;
    //  imgData.data[z+2]=0;
    //  imgData.data[z+3]=255;
    // }
    // ctx_seam.putImageData(imgData,0,0);

    // draw minimum horizontal seam
    // image_data = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
    // new_image = ctx.createImageData(ctx.canvas.width,ctx.canvas.height);
    // for (x = 0; x<width; x++) {
    //   y_offset = 0
    //   for (y = 0; y<height-1; y++) {
    //     if (horizontal_seam[x][1] == y) {
    //       y_offset = 1
    //       idx = (width-1-x)*4 + y*4 * ctx.canvas.width
    //       new_image.data[idx+0]=255
    //       new_image.data[idx+1]=0
    //       new_image.data[idx+2]=0
    //       new_image.data[idx+3]=255
    //     }
    //     idx = (width-1-x)*4 + y*4 * ctx.canvas.width
    //     idx2 = (width-1-x)*4 + (y+y_offset)*4 * ctx.canvas.width
    //     new_image.data[idx+0]=image_data.data[idx2];
    //     new_image.data[idx+1]=image_data.data[idx2+1];
    //     new_image.data[idx+2]=image_data.data[idx2+2];
    //     new_image.data[idx+3]=image_data.data[idx2+3];
    //   }
    // }
        // ctx.canvas.height = ctx.canvas.height-1;
    ctx.putImageData(new_image,0,0);


    // total execution time
    timer.end()
    debug(timer.interval_seconds())
  }

  function debug(str){
    console.log("DEBUG: " + str)
  }

  var timer = {
    start:0,
    stop:0,
    begin: function() {
      this.start = new Date();
    },
    end: function() {
      this.stop = new Date();
    },
    interval_seconds: function() {
      return (this.stop.getTime() - this.start.getTime()) / 1000;
    }
  }



</script>
</html>
