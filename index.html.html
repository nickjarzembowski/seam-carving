<html>
<body>
  <style>
    * {
      margin:0;
      padding:0
    }
    canvas {
      float:left;
      width:25vw;
    }
  </style>
  <canvas id="canvas"></canvas>
  <canvas id="canvas_extra"></canvas>
  <canvas id="canvas_seam"></canvas>
</body>
<script>
  window.onload = function(){
    debug("page loaded")

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var canvas_extra = document.getElementById('canvas_extra');
    var ctx_extra = canvas_extra.getContext('2d');
    var canvas_seam = document.getElementById('canvas_seam');
    var ctx_seam = canvas_seam.getContext('2d');

    // load image
    var img = new Image();
    img.src = './p2.png';
    img.crossOrigin = "Anonymous";
    img.onload = function() {
      ctx.canvas.width = img.width;
      ctx.canvas.height = img.height;
      ctx_extra.canvas.width = img.width;
      ctx_extra.canvas.height = img.height;
      ctx_seam.canvas.width = img.width;
      ctx_seam.canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      image_data = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
      height = image_data.height;
      width = image_data.width;
      ctx_seam.putImageData(image_data,0,0);

      window.onkeypress = function(e){
        if (e.keyCode == 104){
          timer.begin()

          // compute horizontal gradients
          var grad = new Array(width)
          for (i = 0; i < width; i++){
            grad[i] = new Array(height)
          }

          imgData = ctx_extra.getImageData(0,0,ctx_extra.canvas.width,ctx_extra.canvas.height)

          // get vertical seams
          nWidth = width*4;
          nHeight = height*4;
          for (y = 0; y < nHeight; y+=4) {
            for (x = 0; x < nWidth; x+=4) {

              idx = x + y * width

              center_r = image_data.data[idx]
              center_g = image_data.data[idx+1]
              center_b = image_data.data[idx+2]
              center_a = image_data.data[idx+3]

              left = (x == 0 ? idx : ( (x-4) + y * width))
              right = (x == nWidth-1 ? idx : ( (x+4) + y * width))

              left_r = image_data.data[left]
              left_g = image_data.data[left+1]
              left_b = image_data.data[left+2]
              left_a = image_data.data[left+3]

              right_r = image_data.data[right]
              right_g = image_data.data[right+1]
              right_b = image_data.data[right+2]
              right_a = image_data.data[right+3]

              r = left_r - right_r;
              g = left_g - right_g;
              b = left_b - right_b;

              distance = Math.sqrt(r*r + g*g + b*b);

              grad[x/4][y/4] = distance

              // check i'm scanning ok
              imgData.data[idx] = center_r
              imgData.data[idx+1] = center_g
              imgData.data[idx+2] = center_b
              imgData.data[idx+3] = center_a
            }
          }
          ctx_extra.putImageData(imgData,0,0);

          // draw gradient
          imgData = ctx_extra.getImageData(0,0,ctx_extra.canvas.width,ctx_extra.canvas.height);
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              n = grad[x][y];
              r = n >> 24 & 255;
              g = n >> 16 & 255;
              b = n >> 8 & 255;
              a = n >> 0 & 255;
              i = (x*4 + y*4 * width)
              imgData.data[i]=r;
              imgData.data[i+1]=g;
              imgData.data[i+2]=b;
              imgData.data[i+3]=a;
            }
          }
          ctx_extra.putImageData(imgData,0,0);

          vertical_fitness = new Array(width)
          for (var i = 0; i < width; i++) {
            vertical_fitness[i] = new Array(height)
          }
          for (var x = 0; x < width; x++) {
            vertical_fitness[x][0] = grad[x][0]
          }
          for (y = 1; y < height; y++) {
            for (x = 0; x < width; x++) {
              vertical_fitness[x][y] = grad[x][y]
              if (x == 0) {
                vertical_fitness[x][y] += Math.min(vertical_fitness[x][y-1], vertical_fitness[x+1][y-1]);
              } else if (x == width-1) {
                vertical_fitness[x][y] += Math.min(vertical_fitness[x][y-1], vertical_fitness[x-1][y-1]);
              } else {
                vertical_fitness[x][y] += Math.min(vertical_fitness[x-1][y-1], vertical_fitness[x][y-1], vertical_fitness[x+1][y-1]);
              }
            }
          }

          var best = 0
          for (var x = 0; x < width; x++) {
            best = (vertical_fitness[x][height-1] < vertical_fitness[best][height-1]) ? x : best
          }
          seam = Array.apply(null, new Array(height)).map(Number.prototype.valueOf,0)
          seam = new Array()
          seam[0] = [best,y]
          for (y = height-1; y >= 0; y--) {
           left = (best == 0) ? best : (best-1);
           right = (best == width-1) ? best : (best+1);
           forward = (y == 0) ? y : (y-1);
           l = vertical_fitness[left][forward]
           r = vertical_fitness[right][forward]
           f = vertical_fitness[best][forward]
           best = (l < r) ? ( (l < f) ? left : best ) : right
           seam.push([best,y])
          }

        // draw seam
        imgData = ctx_seam.getImageData(0,0,ctx_seam.canvas.width,ctx_seam.canvas.height);
        for (var i=0; i<seam.length; i++) {
         x = seam[i][0]
         y = seam[i][1]
         z = (x*4 + y*4 * ctx.canvas.width)
         imgData.data[z+0]=255;
         imgData.data[z+1]=0;
         imgData.data[z+2]=0;
         imgData.data[z+3]=255;
        }
        ctx_seam.putImageData(imgData,0,0);

        // remove seam
        image_data = ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
        ctx.canvas.width = ctx.canvas.width-1;
        ctx.putImageData(image_data,0,0);
        imgData = ctx_extra.getImageData(0,0,ctx_extra.canvas.width,ctx_extra.canvas.height);
        ctx_extra.canvas.width = ctx_extra.canvas.width-1;
        ctx_extra.putImageData(imgData,0,0);

        }
        // total execution time
        timer.end()
        debug(timer.interval_seconds())
      }
    }
  }

  function debug(str){
    console.log("DEBUG: " + str)
  }

  var timer = {
    start:0,
    stop:0,
    begin: function() {
      this.start = new Date();
    },
    end: function() {
      this.stop = new Date();
    },
    interval_seconds: function() {
      return (this.stop.getTime() - this.start.getTime()) / 1000;
    }
  }



</script>
</html>
